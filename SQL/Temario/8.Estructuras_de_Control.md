| **Inicio**            | **atr谩s 7**                    | **Siguiente 9**                                   |
| --------------------- | ------------------------------ | ------------------------------------------------- |
| [](../../README.md) | [](./7.Stored_Procedures.md) | [](./9.Operadores_Aritmeticos_y_Comparacion.md) |

---

## **ndice**

| Temario                                                                                         |
| ----------------------------------------------------------------------------------------------- |
| [Introducci贸n](#introducci贸n)                                                                   |
| [El condicional IF ELSE y estructura BEGIN END](#el-condicional-if-else-y-estructura-begin-end) |
| [La funci贸n EXISTS](#la-funci贸n-exists)                                                         |
| [El bucle WHILE](#el-bucle-while)                                                               |
| [El condicional CASE](#el-condicional-case)                                                     |
| [Las instrucciones RETURN y BREAK](#las-instrucciones-return-y-break)                           |
| [La estructura TRY CATCH](#la-estructura-try-catch)                                             |
| [Conclusi贸n](#conclusi贸n)                                                                       |

---

# **Estructuras de Control**

---

## **Introducci贸n**

En SQL Server, las estructuras de control son utilizadas para tomar decisiones y controlar el flujo de ejecuci贸n de las consultas y scripts. Permiten realizar acciones condicionales o repetitivas en funci贸n de ciertas condiciones. Las estructuras de control m谩s comunes en SQL Server son las siguientes:

1. **Estructura IF:** La estructura `IF` permite ejecutar un bloque de c贸digo SQL si se cumple una condici贸n especificada. El formato b谩sico de la estructura `IF` en SQL Server es el siguiente:

```
IF condici贸n
BEGIN
    -- C贸digo a ejecutar si la condici贸n es verdadera
END
```

Aqu铆 hay un ejemplo utilizando la base de datos Northwind. Supongamos que queremos obtener todos los productos cuyo precio sea mayor que `$20`:

```
USE Northwind;
GO

IF EXISTS (SELECT * FROM Products WHERE UnitPrice > 20)
BEGIN
    SELECT * FROM Products WHERE UnitPrice > 20;
END
ELSE
BEGIN
    PRINT 'No se encontraron productos con un precio mayor a $20.';
END
```

En este ejemplo, la condici贸n `UnitPrice > 20` verifica si hay alg煤n producto en la tabla "`Products`" cuyo precio sea mayor a `$20`. Si se cumple la condici贸n, se ejecuta la consulta `SELECT` para obtener los productos. Si la condici贸n no se cumple, se imprime un mensaje indicando que no se encontraron productos con ese criterio.

2. **Estructura CASE:** La estructura `CASE` permite realizar m煤ltiples evaluaciones y ejecutar diferentes bloques de c贸digo dependiendo de los resultados. Hay dos formas de escribir una estructura `CASE`: la forma simple y la forma buscada.

- **Forma simple:**

```
CASE expresi贸n
    WHEN valor1 THEN resultado1
    WHEN valor2 THEN resultado2
    ...
    ELSE resultado_final
END
```

- **Forma buscada:**

```
CASE
    WHEN condici贸n1 THEN resultado1
    WHEN condici贸n2 THEN resultado2
    ...
    ELSE resultado_final
END
```

Veamos un ejemplo utilizando la base de datos Northwind. Supongamos que queremos clasificar los productos de acuerdo a su precio en tres categor铆as: "`Bajo`", "`Medio`" y "`Alto`":

```
USE Northwind;
GO

SELECT ProductName,
    CASE
        WHEN UnitPrice < 10 THEN 'Bajo'
        WHEN UnitPrice >= 10 AND UnitPrice <= 20 THEN 'Medio'
        ELSE 'Alto'
    END AS 'Categor铆a Precio'
FROM Products;
```

En este ejemplo, utilizamos la estructura `CASE` para evaluar el precio de cada producto y asignar una categor铆a en funci贸n de su valor. Si el precio es menor a `10`, se clasifica como "`Bajo`". Si est谩 entre `10` y `20`, se clasifica como "`Medio`". De lo contrario, se clasifica como "`Alto`".

Estas son solo algunas de las estructuras de control disponibles en SQL Server. Puedes combinarlas y utilizarlas de diferentes formas para controlar el flujo de ejecuci贸n y realizar acciones condicionales o repetitivas en tus consultas y scripts.

[](#铆ndice)

---

## **El condicional IF ELSE y estructura BEGIN END**

En SQL Server, el condicional `IF ELSE` junto con la estructura `BEGIN END` se utiliza para realizar acciones condicionales en funci贸n de una condici贸n especificada. Permite ejecutar un bloque de c贸digo si la condici贸n es verdadera (`IF`) y otro bloque de c贸digo si la condici贸n es falsa (`ELSE`). La estructura `BEGIN END` se utiliza para agrupar m煤ltiples declaraciones SQL dentro de un bloque, lo que permite ejecutar varias instrucciones en cada rama del condicional.

Aqu铆 tienes un ejemplo utilizando la base de datos Northwind. Supongamos que queremos verificar si hay alg煤n producto en la tabla "`Products`" cuyo precio sea mayor a `$20`. Si es as铆, mostraremos los detalles de esos productos, de lo contrario, mostraremos un mensaje indicando que no se encontraron productos con un precio mayor a `$20`.

```
USE Northwind;
GO

IF EXISTS (SELECT * FROM Products WHERE UnitPrice > 20)
BEGIN
    SELECT ProductName, UnitPrice
    FROM Products
    WHERE UnitPrice > 20;
END
ELSE
BEGIN
    PRINT 'No se encontraron productos con un precio mayor a $20.';
END
```

En este ejemplo, utilizamos el condicional `IF ELSE` para verificar la existencia de productos cuyo precio sea mayor a `$20`. Si la condici贸n `EXISTS` (`SELECT * FROM Products WHERE UnitPrice > 20`) es verdadera, se ejecuta el bloque de c贸digo dentro del primer `BEGIN` y se muestra la informaci贸n de los productos que cumplen la condici贸n. Si la condici贸n es falsa, se ejecuta el bloque de c贸digo dentro del segundo `BEGIN` y se imprime el mensaje indicando que no se encontraron productos con un precio mayor a `$20`.

La estructura `BEGIN END` se utiliza para agrupar las instrucciones SQL dentro de cada rama del condicional. Esto permite ejecutar m煤ltiples instrucciones en cada caso (`IF` y `ELSE`) y mantener el control del flujo de ejecuci贸n.

Es importante destacar que la estructura `IF ELSE` se puede anidar, es decir, puedes tener un condicional `IF` dentro de otro condicional `IF` o dentro de la rama `ELSE`. Esto te permite realizar evaluaciones m谩s complejas y tomar decisiones en funci贸n de m煤ltiples condiciones.

Recuerda que el uso de `BEGIN` y `END` es opcional si solo tienes una instrucci贸n dentro de cada rama del condicional. Sin embargo, si deseas ejecutar m煤ltiples instrucciones, es necesario utilizar estas estructuras para agruparlas correctamente.

[](#铆ndice)

---

## **La funci贸n EXISTS**

En SQL Server, la funci贸n `EXISTS` se utiliza para verificar si existe al menos un registro que cumpla una determinada condici贸n en una consulta. Retorna un valor booleano (verdadero o falso) en funci贸n de si se encuentra o no alg煤n registro que cumpla la condici贸n especificada.

La funci贸n `EXISTS` se utiliza com煤nmente junto con el condicional `IF` para realizar acciones condicionales en funci贸n de la existencia de registros. Tambi茅n se puede utilizar en subconsultas para filtrar los resultados en funci贸n de una condici贸n.

Aqu铆 tienes un ejemplo utilizando la base de datos Northwind. Supongamos que queremos verificar si existen pedidos para un cliente espec铆fico con el identificador "`ALFKI`":

```
USE Northwind;
GO

IF EXISTS (SELECT * FROM Orders WHERE CustomerID = 'ALFKI')
BEGIN
    PRINT 'El cliente ALFKI tiene pedidos.';
END
ELSE
BEGIN
    PRINT 'El cliente ALFKI no tiene pedidos.';
END
```

En este ejemplo, utilizamos la funci贸n `EXISTS` en la subconsulta (`SELECT * FROM Orders WHERE CustomerID = 'ALFKI'`). La condici贸n `CustomerID = 'ALFKI'` verifica si hay alg煤n pedido en la tabla "`Orders`" asociado al cliente con el identificador "`ALFKI`". Si la funci贸n `EXISTS` retorna verdadero, se ejecuta el bloque de c贸digo dentro del primer `BEGIN` y se imprime el mensaje indicando que el cliente tiene pedidos. Si la funci贸n `EXISTS` retorna falso, se ejecuta el bloque de c贸digo dentro del segundo `BEGIN` y se imprime el mensaje indicando que el cliente no tiene pedidos.

Es importante destacar que la funci贸n `EXISTS` se eval煤a de manera eficiente, ya que devuelve un valor tan pronto como se encuentra un registro que cumple la condici贸n. Esto significa que no se realiza una b煤squeda completa en la tabla, sino que se detiene tan pronto como se encuentra un registro v谩lido. Esto puede mejorar el rendimiento de la consulta, especialmente cuando se trabaja con grandes conjuntos de datos.

En resumen, la funci贸n `EXISTS` es utilizada en SQL Server para verificar la existencia de registros que cumplan una condici贸n espec铆fica en una consulta. Es com煤nmente utilizada en combinaci贸n con el condicional `IF` para realizar acciones condicionales en funci贸n de la presencia o ausencia de registros.

[](#铆ndice)

---

## **El bucle WHILE**

En SQL Server, el bucle `WHILE` se utiliza para repetir un bloque de c贸digo SQL mientras se cumpla una condici贸n espec铆fica. El bloque de c贸digo se ejecuta repetidamente hasta que la condici贸n se eval煤a como falsa. Esto permite realizar iteraciones basadas en una condici贸n y controlar el flujo de ejecuci贸n de manera repetitiva.

El bucle `WHILE` se compone de dos elementos principales: la condici贸n y el bloque de c贸digo a repetir. La condici贸n se eval煤a antes de cada iteraci贸n. Si la condici贸n es verdadera, se ejecuta el bloque de c贸digo. Despu茅s de la ejecuci贸n del bloque, la condici贸n se vuelve a evaluar. Si la condici贸n es falsa, el bucle se detiene y la ejecuci贸n contin煤a con la siguiente instrucci贸n despu茅s del bucle.

Aqu铆 tienes un ejemplo utilizando la base de datos Northwind. Supongamos que queremos imprimir los nombres de los productos cuyos precios sean mayores a `$50`. Utilizaremos el bucle `WHILE` para iterar sobre la tabla "`Products`" y realizar la verificaci贸n de cada producto:

```
USE Northwind;
GO

DECLARE @ProductName NVARCHAR(50);
DECLARE @Price MONEY;

DECLARE @Counter INT = 1;
DECLARE @TotalProducts INT;

SELECT @TotalProducts = COUNT(*) FROM Products;

WHILE @Counter <= @TotalProducts
BEGIN
    SELECT @ProductName = ProductName, @Price = UnitPrice
    FROM (
        SELECT ROW_NUMBER() OVER (ORDER BY ProductID) AS RowNum, ProductName, UnitPrice
        FROM Products
    ) AS ProductsWithRowNum
    WHERE RowNum = @Counter;

    IF @Price > 50
    BEGIN
        PRINT @ProductName;
    END

    SET @Counter = @Counter + 1;
END
```

En este ejemplo, declaramos variables para almacenar el nombre del producto y el precio. Tambi茅n inicializamos una variable de contador (`@Counter`) con `1` y obtenemos el n煤mero total de productos en la tabla "`Products`" en la variable `@TotalProducts`.

Dentro del bucle `WHILE`, utilizamos una consulta con `ROW_NUMBER()` para asignar un n煤mero de fila a cada producto en orden ascendente por el identificador del producto (`ProductID`). Luego, filtramos la consulta para obtener el producto correspondiente al valor actual del contador (`@Counter`).

Si el precio del producto es mayor a `$50`, imprimimos su nombre utilizando la instrucci贸n `PRINT`.

Despu茅s de cada iteraci贸n, incrementamos el contador (`@Counter`) en `1` para pasar al siguiente producto en la tabla. El bucle contin煤a hasta que el contador alcance el n煤mero total de productos y la condici贸n `@Counter <= @TotalProducts` se eval煤e como falsa.

El bucle `WHILE` es 煤til cuando se requiere realizar una acci贸n repetitiva basada en una condici贸n que no se puede lograr con una consulta 煤nica. Sin embargo, es importante tener cuidado al utilizar bucles en consultas SQL, ya que pueden tener un impacto en el rendimiento si no se manejan correctamente.

[](#铆ndice)

---

## **El condicional CASE**

En SQL Server, el condicional `CASE` se utiliza para realizar evaluaciones condicionales y ejecutar diferentes bloques de c贸digo en funci贸n de los resultados. Puede ser utilizado tanto en consultas `SELECT` como en instrucciones `UPDATE` o `INSERT`.

El condicional `CASE` tiene dos formas principales: la forma simple y la forma buscada.

1. **Forma simple del condicional CASE:**

La forma simple del condicional `CASE` se utiliza para evaluar una expresi贸n y ejecutar diferentes bloques de c贸digo en funci贸n de los valores posibles de la expresi贸n. El formato b谩sico es el siguiente:

```
CASE expresi贸n
    WHEN valor1 THEN resultado1
    WHEN valor2 THEN resultado2
    ...
    ELSE resultado_final
END
```

Aqu铆 tienes un ejemplo utilizando la base de datos Northwind. Supongamos que queremos clasificar los productos seg煤n su unidad de existencia. Si la unidad de existencia es menor o igual a `10`, la clasificaremos como "`Baja`"; si es mayor a `10` y menor o igual a `20`, la clasificaremos como "`Media`"; de lo contrario, la clasificaremos como "`Alta`":

```
USE Northwind;
GO

SELECT ProductName, UnitsInStock,
    CASE
        WHEN UnitsInStock <= 10 THEN 'Baja'
        WHEN UnitsInStock > 10 AND UnitsInStock <= 20 THEN 'Media'
        ELSE 'Alta'
    END AS 'Clasificaci贸n'
FROM Products;
```

En este ejemplo, utilizamos el condicional `CASE` para evaluar el valor de la columna "`UnitsInStock`" de la tabla "`Products`". Seg煤n el valor de "`UnitsInStock`", asignamos una clasificaci贸n espec铆fica a cada producto. Si el valor es menor o igual a `10`, la clasificaci贸n ser谩 "`Baja`". Si el valor est谩 entre `10` y `20` (incluyendo ambos extremos), la clasificaci贸n ser谩 "`Media`". De lo contrario, la clasificaci贸n ser谩 "`Alta`".

2. **Forma buscada del condicional CASE:**

La forma buscada del condicional `CASE` se utiliza cuando se requieren evaluaciones m谩s complejas y no se basan en valores espec铆ficos. En lugar de especificar valores, se especifican condiciones dentro del condicional `CASE`. El formato es el siguiente:

```
CASE
    WHEN condici贸n1 THEN resultado1
    WHEN condici贸n2 THEN resultado2
    ...
    ELSE resultado_final
END
```

Aqu铆 tienes un ejemplo utilizando la base de datos Northwind. Supongamos que queremos clasificar los empleados en funci贸n de su pa铆s de origen. Si son de Estados Unidos, los clasificaremos como "`Nacional`"; si son de Reino Unido, los clasificaremos como "`Internacional`"; de lo contrario, los clasificaremos como "`Desconocido`":

```
USE Northwind;
GO

SELECT EmployeeID, FirstName, LastName, Country,
    CASE
        WHEN Country = 'USA' THEN 'Nacional'
        WHEN Country = 'UK' THEN 'Internacional'
        ELSE 'Desconocido'
    END AS 'Clasificaci贸n'
FROM Employees;
```

En este ejemplo, utilizamos el condicional `CASE` para evaluar el valor de la columna "`Country`" de la tabla "`Employees`". Seg煤n el valor de "`Country`", asignamos una clasificaci贸n espec铆fica a cada empleado. Si el pa铆s es "`USA`", la clasificaci贸n ser谩 "`Nacional`". Si el pa铆s es "`UK`", la clasificaci贸n ser谩 "`Internacional`". De lo contrario, la clasificaci贸n ser谩 "`Desconocido`".

En resumen, el condicional `CASE` en SQL Server es utilizado para realizar evaluaciones condicionales y ejecutar diferentes bloques de c贸digo en funci贸n de los resultados. Puede ser utilizado tanto en consultas `SELECT` como en instrucciones `UPDATE` o `INSERT`. Existen dos formas principales: la forma simple, que eval煤a valores espec铆ficos, y la forma buscada, que eval煤a condiciones m谩s complejas. El condicional `CASE` es una herramienta 煤til para realizar transformaciones y clasificaciones en base a condiciones espec铆ficas en los datos.

[](#铆ndice)

---

## **Las instrucciones RETURN y BREAK**

En SQL Server, las instrucciones `RETURN` y `BREAK` se utilizan para controlar el flujo de ejecuci贸n en bloques de c贸digo, como procedimientos almacenados, funciones y bucles. Cada una tiene un prop贸sito espec铆fico y se utiliza en diferentes contextos.

1. **Instrucci贸n RETURN:**

La instrucci贸n `RETURN` se utiliza para finalizar la ejecuci贸n de un procedimiento almacenado o una funci贸n y devolver un valor opcional. Cuando se encuentra una instrucci贸n `RETURN`, se sale inmediatamente del bloque de c贸digo actual y se devuelve el control al punto de llamada.
Aqu铆 tienes un ejemplo utilizando la base de datos Northwind. Supongamos que queremos crear una funci贸n que reciba el identificador de un cliente y devuelva su nombre. Si el cliente no existe, queremos que la funci贸n devuelva un mensaje indicando que el cliente no fue encontrado:

```
USE Northwind;
GO

CREATE FUNCTION ObtenerNombreCliente (@CustomerID nvarchar(5))
RETURNS nvarchar(40)
AS
BEGIN
    DECLARE @NombreCliente nvarchar(40);

    SELECT @NombreCliente = ContactName
    FROM Customers
    WHERE CustomerID = @CustomerID;

    IF @NombreCliente IS NULL
    BEGIN
        RETURN 'Cliente no encontrado.';
    END

    RETURN @NombreCliente;
END
```

En este ejemplo, creamos una funci贸n llamada "`ObtenerNombreCliente`" que recibe el identificador de un cliente como par谩metro. Dentro de la funci贸n, realizamos una consulta para obtener el nombre del cliente asociado al identificador proporcionado.

Si el nombre del cliente es nulo, utilizamos la instrucci贸n `RETURN` para salir de la funci贸n y devolver el mensaje "`Cliente no encontrado.`". Si el nombre del cliente existe, utilizamos la instrucci贸n `RETURN` para devolver el nombre del cliente.

2. **Instrucci贸n BREAK:**

La instrucci贸n `BREAK` se utiliza en bucles (como `WHILE` y `FOR`) para salir inmediatamente del bucle y continuar con la ejecuci贸n de la siguiente instrucci贸n fuera del bucle.
Aqu铆 tienes un ejemplo utilizando la base de datos Northwind. Supongamos que queremos imprimir los nombres de los productos hasta que se encuentre un producto con un precio mayor a `$100`:

```
USE Northwind;
GO

DECLARE @ProductName nvarchar(50);
DECLARE @Price money;

DECLARE @Counter INT = 1;
DECLARE @TotalProducts INT;

SELECT @TotalProducts = COUNT(*) FROM Products;

WHILE @Counter <= @TotalProducts
BEGIN
    SELECT @ProductName = ProductName, @Price = UnitPrice
    FROM (
        SELECT ROW_NUMBER() OVER (ORDER BY ProductID) AS RowNum, ProductName, UnitPrice
        FROM Products
    ) AS ProductsWithRowNum
    WHERE RowNum = @Counter;

    IF @Price > 100
    BEGIN
        PRINT 'Se encontr贸 un producto con precio mayor a $100.';
        BREAK;
    END

    PRINT @ProductName;

    SET @Counter = @Counter + 1;
END
```

En este ejemplo, utilizamos el bucle `WHILE` para iterar sobre la tabla "`Products`" y verificar el precio de cada producto. Si encontramos un producto con un precio mayor a `$100`, utilizamos la instrucci贸n `BREAK` para salir del bucle y mostrar un mensaje indicando que se encontr贸 un producto con precio mayor a `$100`. De lo contrario, imprimimos el nombre del producto y continuamos con la siguiente iteraci贸n del bucle.

La instrucci贸n `BREAK` es 煤til cuando se necesita terminar prematuramente un bucle en funci贸n de una condici贸n espec铆fica. Permite salir del bucle antes de que se haya completado la iteraci贸n completa.

En resumen, las instrucciones `RETURN` y `BREAK` son utilizadas en SQL Server para controlar el flujo de ejecuci贸n en bloques de c贸digo. `RETURN` se utiliza para finalizar la ejecuci贸n de un procedimiento almacenado o una funci贸n y devolver un valor opcional, mientras que `BREAK` se utiliza en bucles para salir del bucle de manera prematura. Ambas instrucciones son herramientas importantes para el control del flujo de ejecuci贸n y permiten personalizar el comportamiento de los bloques de c贸digo en funci贸n de condiciones espec铆ficas.

[](#铆ndice)

---

## **La estructura TRY CATCH**

En SQL Server, la estructura `TRY CATCH` se utiliza para capturar y manejar errores que pueden ocurrir durante la ejecuci贸n de un bloque de c贸digo. Permite gestionar de manera controlada las excepciones y tomar acciones espec铆ficas en caso de producirse un error.

La estructura `TRY CATCH` consta de dos partes principales: el bloque `TRY` y el bloque `CATCH`.

El bloque `TRY` es el bloque de c贸digo donde se ejecutan las instrucciones que pueden generar una excepci贸n. Dentro de este bloque, se incluye el c贸digo que se desea proteger y controlar en caso de que se produzca un error.

El bloque `CATCH` es el bloque donde se manejan las excepciones capturadas. Si ocurre una excepci贸n dentro del bloque `TRY`, el control se transfiere autom谩ticamente al bloque `CATCH` correspondiente, donde se pueden realizar acciones de manejo de errores, como registrar el error, enviar notificaciones, realizar operaciones de limpieza, etc.

Aqu铆 tienes un ejemplo utilizando la base de datos Northwind. Supongamos que queremos insertar un nuevo registro en la tabla "`Customers`", pero tambi茅n queremos manejar cualquier excepci贸n que pueda ocurrir durante la inserci贸n:

```
USE Northwind;
GO

BEGIN TRY
    INSERT INTO Customers (CustomerID, CompanyName, ContactName, ContactTitle, Address, City, Country)
    VALUES ('CUSTOMER1', 'Customer One', 'John Doe', 'Manager', '123 Main St', 'Seattle', 'USA');

    PRINT 'Registro insertado correctamente.';
END TRY
BEGIN CATCH
    PRINT 'Error al insertar el registro:';
    PRINT ERROR_MESSAGE();
END CATCH
```

En este ejemplo, utilizamos la estructura `TRY CATCH` para intentar realizar una inserci贸n en la tabla "`Customers`". Dentro del bloque `TRY`, realizamos la inserci贸n con los valores especificados.

Si la inserci贸n tiene 茅xito, se imprime un mensaje indicando que el registro se insert贸 correctamente.

Si ocurre un error durante la inserci贸n, el control se transfiere al bloque `CATCH` correspondiente. Dentro del bloque `CATCH`, se imprime un mensaje de error, que incluye el mensaje de error espec铆fico devuelto por SQL Server, obtenido a trav茅s de la funci贸n `ERROR_MESSAGE()`.

La estructura `TRY CATCH` es 煤til para gestionar errores y evitar que un error detenga por completo la ejecuci贸n de un bloque de c贸digo. Permite capturar las excepciones, realizar acciones espec铆ficas en funci贸n del tipo de error y mantener el control del flujo de ejecuci贸n en situaciones de error.

Es importante destacar que la estructura `TRY CATCH` no puede capturar todos los errores, como aquellos que ocurren fuera del alcance del bloque `TRY`. Sin embargo, es una herramienta valiosa para manejar la mayor铆a de los errores que pueden ocurrir dentro del bloque protegido.

[](#铆ndice)

---

## **Conclusi贸n**

En conclusi贸n, las estructuras de control en SQL Server son herramientas poderosas que permiten controlar el flujo de ejecuci贸n de un programa, realizar evaluaciones condicionales y manejar excepciones. Estas estructuras proporcionan la capacidad de personalizar el comportamiento de un bloque de c贸digo en funci贸n de condiciones espec铆ficas y manejar errores de manera controlada.

Aqu铆 hay un resumen de las estructuras de control mencionadas y su uso en SQL Server con un ejemplo utilizando la base de datos Northwind:

1. **Estructura IF-ELSE:** Permite realizar evaluaciones condicionales y ejecutar diferentes bloques de c贸digo seg煤n el resultado de la evaluaci贸n. Por ejemplo, clasificar productos seg煤n su unidad de existencia.

2. **Estructura BEGIN-END:** Agrupa m煤ltiples instrucciones en un bloque de c贸digo para que se ejecuten como una unidad. Es utilizado en combinaci贸n con otras estructuras de control. Por ejemplo, en un procedimiento almacenado.

3. **Funci贸n EXISTS:** Se utiliza para verificar la existencia de registros en una tabla o subconsulta. Puede ser 煤til para realizar operaciones condicionales en base a la presencia o ausencia de datos. Por ejemplo, verificar si hay productos en la tabla "`Products`".

4. **Bucle WHILE:** Se utiliza para repetir un bloque de c贸digo mientras se cumple una condici贸n espec铆fica. Es 煤til cuando se necesita ejecutar una serie de instrucciones varias veces. Por ejemplo, imprimir los nombres de los productos hasta encontrar uno con un precio mayor a `$100`.

5. **Condicional CASE:** Permite realizar evaluaciones condicionales m谩s complejas y ejecutar diferentes bloques de c贸digo seg煤n los valores o condiciones especificadas. Puede ser utilizado para transformar datos o asignar categor铆as. Por ejemplo, clasificar empleados seg煤n su pa铆s de origen.

6. **Estructura TRY CATCH:** Permite capturar y manejar excepciones que ocurren durante la ejecuci贸n de un bloque de c贸digo. Permite controlar de manera controlada las excepciones y tomar acciones espec铆ficas en caso de errores. Por ejemplo, realizar una inserci贸n en la tabla "`Customers`" y manejar cualquier excepci贸n que pueda ocurrir.

En general, estas estructuras de control brindan flexibilidad y poder para escribir consultas y procedimientos m谩s robustos y eficientes en SQL Server. Su comprensi贸n y uso adecuado son fundamentales para lograr un c贸digo SQL efectivo y manejar situaciones excepcionales de manera controlada.

[](#铆ndice)

---

| **Inicio**            | **atr谩s 7**                    | **Siguiente 9**                                   |
| --------------------- | ------------------------------ | ------------------------------------------------- |
| [](../../README.md) | [](./7.Stored_Procedures.md) | [](./9.Operadores_Aritmeticos_y_Comparacion.md) |
